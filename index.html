<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>17 Leveling â€“ Ultimate Multiplayer Dungeon Game</title>
    <!-- Import MedievalSharp Font -->
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
    <style>
      /* Global Reset and Base Styles */
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      body {
        font-family: 'MedievalSharp', cursive;
        background: #111;
        color: #eaeaea;
      }
  
      /* Enlarged Game Container */
      #gameContainer {
        margin: 0 auto;
        width: 1000px;
        height: 600px;
        position: relative;
        border: 2px solid #444;
        background: #555;
      }
  
      /* Global Announcement Overlay */
      #globalAnnouncement {
        position: absolute;
        top: 0;
        width: 100%;
        text-align: center;
        z-index: 120;
        display: none;
        pointer-events: none;
      }
  
      /* UI Overlay for HUD */
      #uiOverlay {
        position: absolute;
        width: 100%;
        top: 0;
        left: 0;
        z-index: 10;
        text-align: center;
        pointer-events: auto;
      }
  
      /* Cooldown Display */
      #cooldownDisplay {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 4px;
        font-size: 14px;
        color: #fff;
        z-index: 50;
        pointer-events: auto;
      }
  
      /* Big Notification */
      #bigNotification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.85);
        color: #fff;
        font-size: 32px;
        padding: 20px 40px;
        border-radius: 4px;
        display: none;
        z-index: 90;
        pointer-events: auto;
      }
  
      /* Chat System Styles */
      #chatContainer {
        position: fixed;
        bottom: 10px;
        right: 10px;
        width: 300px;
        max-height: 200px;
        background: rgba(0,0,0,0.85);
        color: #fff;
        font-size: 14px;
        padding: 5px;
        overflow-y: auto;
        border: 1px solid #444;
        z-index: 95;
        border-radius: 4px;
        display: none;
        pointer-events: auto;
      }
      #chatInput {
        width: 90%;
        padding: 5px;
        border: 1px solid #444;
        outline: none;
        margin-top: 5px;
        border-radius: 4px;
        background: #222;
        color: #fff;
      }
      /* Chat Toggle Button & Badge */
      #chatToggle {
        position: fixed;
        bottom: 10px;
        right: 320px;
        z-index: 100;
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        background: #27ae60;
        color: #fff;
        border: none;
        border-radius: 4px;
        pointer-events: auto;
      }
      #chatBadge {
        position: absolute;
        top: -5px;
        right: -5px;
        background: red;
        color: #fff;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        text-align: center;
        font-size: 12px;
        line-height: 20px;
        display: none;
        pointer-events: auto;
      }
  
      /* Admin Panel Toggle Button (visible for admins) */
      #adminToggle {
        position: fixed;
        bottom: 10px;
        left: 10px;
        z-index: 105;
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        background: #e67e22;
        color: #fff;
        border: none;
        border-radius: 4px;
        display: none;
        pointer-events: auto;
      }
  
      /* Controls Overlay */
      #controlsOverlay {
        position: fixed;
        top: 50px;
        right: 10px;
        width: 280px;
        background: rgba(0,0,0,0.9);
        border: 2px solid #444;
        padding: 10px;
        z-index: 80;
        border-radius: 4px;
        display: none;
        font-size: 14px;
        pointer-events: auto;
      }
      #controlsOverlay h2 {
        margin: 0 0 10px;
        font-size: 20px;
        text-align: center;
      }
      #controlsOverlay ul {
        list-style: none;
        padding: 0;
      }
      #controlsOverlay li {
        margin-bottom: 8px;
        line-height: 1.4;
      }
      #controlsToggle {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 110;
        padding: 8px 12px;
        background: #27ae60;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        pointer-events: auto;
      }
  
      /* Account Overlay and Forms */
      #accountOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 1000px;
        height: 600px;
        background: rgba(0,0,0,0.9);
        z-index: 120;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        pointer-events: auto;
      }
      #accountOverlay .mainOptions {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        pointer-events: auto;
      }
      #accountOverlay button {
        padding: 10px 20px;
        font-size: 20px;
        cursor: pointer;
        border: none;
        border-radius: 4px;
        background: #007bff;
        color: #fff;
        transition: background 0.3s;
        pointer-events: auto;
      }
      #accountOverlay button:hover {
        background: #0056b3;
      }
      #createAccountForm, #loginForm {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        margin-top: 20px;
        pointer-events: auto;
      }
      #createAccountForm input, #loginForm input, #createAccountForm select {
        padding: 10px;
        font-size: 18px;
      }
      #accountOverlay .backBtn {
        margin-top: 10px;
        padding: 5px 10px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        background: #555;
        color: #fff;
        border-radius: 4px;
        pointer-events: auto;
      }
  
      /* Class Selection Bar */
      #classSelectionBar {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        background: rgba(0,0,0,0.9);
        z-index: 50;
        display: none;
        justify-content: center;
        gap: 20px;
        padding: 10px 0;
        pointer-events: auto;
      }
      .classBtn {
        background: #007bff;
        color: #fff;
        border: none;
        border-radius: 4px;
        font-size: 20px;
        padding: 10px 20px;
        cursor: pointer;
        transition: background 0.3s;
        position: relative;
        pointer-events: auto;
      }
      .classBtn:hover {
        background: #0056b3;
      }
      #monarchBtn {
        background: gold;
        color: #222;
      }
      #monarchBtn::before, #monarchBtn::after {
        content: "ðŸ‘‘";
        position: absolute;
        top: -20px;
        font-size: 20px;
      }
      #monarchBtn::before {
        left: -20px;
      }
      #monarchBtn::after {
        right: -20px;
      }
  
      /* Monarch Unlock Overlay */
      #monarchOverlay {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 400px;
        background: rgba(0,0,0,0.95);
        z-index: 130;
        display: none;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        border: 2px solid red;
        border-radius: 8px;
        pointer-events: auto;
      }
      #monarchOverlay h2 {
        color: red;
        margin-bottom: 10px;
        font-size: 20px;
      }
      #monarchOverlay input {
        padding: 10px;
        font-size: 18px;
        margin-bottom: 10px;
        width: 80%;
      }
      #monarchOverlay button {
        padding: 8px 16px;
        font-size: 18px;
        cursor: pointer;
        pointer-events: auto;
      }
      #monarchOverlay .closeBtn {
        position: absolute;
        top: 5px;
        right: 10px;
        background: transparent;
        border: none;
        color: red;
        font-size: 24px;
        cursor: pointer;
        pointer-events: auto;
      }
  
      /* Dungeon Panel */
      #dungeonPanel {
        position: absolute;
        width: 300px;
        background: rgba(30,30,30,0.95);
        padding: 10px;
        border: 2px solid #555;
        z-index: 70;
        display: none;
        cursor: move;
        pointer-events: auto;
      }
      #dungeonPanel h1 {
        margin: 5px 0;
        text-align: center;
        font-size: 26px;
      }
      #dungeonPanel ul {
        list-style: none;
        padding: 0;
      }
      #dungeonPanel li {
        margin: 3px 0;
        padding: 3px;
        border: 1px solid #777;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
      }
      #dungeonPanel li:hover {
        background: #333;
      }
      #dungeonPanel button {
        margin-top: 5px;
        padding: 5px 10px;
        font-size: 14px;
        cursor: pointer;
        pointer-events: auto;
      }
  
      /* Admin Panel - Completely Revamped */
      #adminPanel {
        position: fixed;
        top: 10%;
        right: 5%;
        width: 400px;
        background: linear-gradient(135deg, #444, #222);
        border: 2px solid #27ae60;
        border-radius: 8px;
        z-index: 140;
        display: none;
        resize: both;
        overflow: auto;
        color: #eaeaea;
        padding: 20px;
        box-shadow: 0 6px 20px rgba(0,0,0,0.8);
      }
      #adminPanel h2 {
        margin-top: 0;
        background: #27ae60;
        padding: 14px;
        border-top-left-radius: 6px;
        border-top-right-radius: 6px;
        text-align: center;
        font-size: 24px;
        color: #fff;
      }
      #adminPanel .playerList {
        list-style: none;
        margin: 0;
        padding: 10px;
      }
      #adminPanel .playerList li {
        margin: 10px 0;
        padding: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #333;
        border-radius: 4px;
      }
      #adminPanel .playerList li span {
        font-size: 16px;
      }
      #adminPanel button {
        padding: 6px 12px;
        font-size: 14px;
        cursor: pointer;
        background: #007bff;
        border: none;
        color: #fff;
        border-radius: 4px;
        transition: background 0.3s;
      }
      #adminPanel button:hover {
        background: #0056b3;
      }
      #adminPanel .closeBtn {
        position: absolute;
        top: 5px;
        right: 10px;
        background: transparent;
        border: none;
        color: #fff;
        font-size: 26px;
        cursor: pointer;
        pointer-events: auto;
      }
      /* Global Announcement Section in Admin Panel */
      #adminAnnouncement {
        margin-top: 20px;
        padding: 10px;
        background: #555;
        border-radius: 4px;
      }
      #adminAnnouncement input[type="text"] {
        width: 100%;
        padding: 6px;
        margin-bottom: 8px;
        border: 1px solid #777;
        border-radius: 4px;
      }
      #adminAnnouncement input[type="color"],
      #adminAnnouncement select {
        padding: 4px;
        margin-right: 8px;
        border: 1px solid #777;
        border-radius: 4px;
      }
      #adminAnnouncement button {
        padding: 6px 12px;
        font-size: 14px;
        cursor: pointer;
        background: #27ae60;
        border: none;
        color: #fff;
        border-radius: 4px;
      }
  
      /* Class Panel */
      #classPanel {
        position: fixed;
        top: 20%;
        left: 10px;
        width: 280px;
        height: auto;
        background: linear-gradient(135deg, #3498db, #2980b9);
        border: none;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        z-index: 140;
        display: none;
        resize: both;
        overflow: auto;
        color: #fff;
        padding-bottom: 10px;
        pointer-events: auto;
      }
      #classPanel h2 {
        margin: 0;
        padding: 15px;
        background: rgba(0,0,0,0.3);
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        text-align: center;
        font-size: 22px;
      }
      #classPanel .closeBtn {
        position: absolute;
        top: 5px;
        right: 10px;
        background: transparent;
        border: none;
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        pointer-events: auto;
      }
      #classPanel button {
        width: 90%;
        margin: 10px auto;
        display: block;
        padding: 10px;
        background: #fff;
        color: #2980b9;
        border: 2px solid #fff;
        border-radius: 4px;
        font-size: 18px;
        cursor: pointer;
        transition: background 0.3s, color 0.3s;
        pointer-events: auto;
      }
      #classPanel button:hover {
        background: #2980b9;
        color: #fff;
      }
  
      /* Canvas Styling */
      canvas {
        display: block;
        margin: 0 auto;
        background: #333;
      }
    </style>
  </head>
  <body>
    <!-- Controls Overlay Toggle -->
    <button id="controlsToggle" onclick="toggleControls()">Controls</button>
    <!-- Admin Panel Toggle Button (visible for admins) -->
    <button id="adminToggle" onclick="toggleAdminPanel()">Admin Panel</button>
    <!-- Controls Overlay -->
    <div id="controlsOverlay">
      <h2>Game Controls</h2>
      <ul>
        <li><strong>Movement:</strong> Arrow Keys</li>
        <li><strong>Dodge (R):</strong> Dash</li>
        <li><strong>Fighter:</strong> F - Attack; G - Heavy Blow (Shockwave)</li>
        <li><strong>Summoner:</strong> F - Attack; G - Summon Soldiers</li>
        <li><strong>Healer:</strong> F - Heal Self; G - Heal Allies</li>
        <li><strong>Monarch:</strong> F - Attack; G - Summon Soldiers; H - Special Activation</li>
        <li><strong>Goliath:</strong> F - Goliath F; G - Goliath G; H - Goliath H; T - Transformation</li>
        <li><strong>Chat:</strong> Global by default; use "@username" for Private</li>
      </ul>
    </div>
  
    <!-- Global Announcement Overlay -->
    <div id="globalAnnouncement"></div>
  
    <!-- Big Notification -->
    <div id="bigNotification"></div>
  
    <div id="gameContainer">
      <canvas id="gameCanvas" width="1000" height="600"></canvas>
      <!-- Cooldown Display -->
      <div id="cooldownDisplay"></div>
      <!-- UI Overlay -->
      <div id="uiOverlay">
        <div id="infoText" style="padding: 5px; background: rgba(0,0,0,0.5); display: inline-block;">
          <span id="playerInfo">Class: </span> |
          <span id="levelInfo">Level: </span> |
          <span id="xpInfo">XP: </span> |
          <span id="hpInfo">HP: </span> |
          <span id="coinInfo">Coins: </span> |
          <span id="waveInfo"></span>
        </div>
      </div>
      <!-- Account Overlay (shown by default for new players) -->
      <div id="accountOverlay">
        <div class="mainOptions">
          <button onclick="showCreateAccount()">Create Account</button>
          <button onclick="showLogin()">Log In</button>
          <button onclick="guestMode()">Play as Guest</button>
        </div>
        <div id="createAccountForm">
          <h3>Create Account</h3>
          <input type="text" id="createUsername" placeholder="Username" />
          <input type="password" id="createPassword" placeholder="Password" />
          <label>Choose Your Color:</label>
          <select id="createColor">
            <option value="#27ae60" selected>Green</option>
            <option value="#3498db">Blue</option>
            <option value="#e74c3c">Red</option>
            <option value="#f1c40f">Yellow</option>
            <option value="#8e44ad">Purple</option>
          </select>
          <button onclick="createAccount()">Submit</button>
          <button class="backBtn" onclick="hideCreateAccount(); showAccountOptions();">Back</button>
        </div>
        <div id="loginForm">
          <h3>Log In</h3>
          <input type="text" id="loginUsername" placeholder="Username" />
          <input type="password" id="loginPassword" placeholder="Password" />
          <button onclick="loginAccount()">Submit</button>
          <button class="backBtn" onclick="hideLogin(); showAccountOptions();">Back</button>
        </div>
      </div>
      <!-- Class Selection Bar -->
      <div id="classSelectionBar">
        <button class="classBtn" onclick="startGame('Summoner')">Summoner</button>
        <button class="classBtn" onclick="startGame('Fighter')">Fighter</button>
        <button class="classBtn" onclick="startGame('Healer')">Healer</button>
        <button class="classBtn" id="monarchBtn" onclick="attemptMonarch()">Monarch</button>
      </div>
      <!-- Monarch Unlock Overlay -->
      <div id="monarchOverlay">
        <button class="closeBtn" onclick="closeMonarchOverlay()">Ã—</button>
        <h2>This class is only available to Testers and Developers ONLY!</h2>
        <h1>Enter Code</h1>
        <input type="text" id="monarchCode" placeholder="Enter code here" />
        <button onclick="checkMonarchCode()">Submit</button>
      </div>
      <!-- Dungeon Panel -->
      <div id="dungeonPanel">
        <h1>DUNGEON</h1>
        <ul id="dungeonList">
          <!-- Dynamically populated -->
        </ul>
        <button onclick="closeDungeonPanel()">Close</button>
      </div>
    </div>
  
    <!-- Chat Toggle Button -->
    <button id="chatToggle" onclick="toggleChat()">Chat <span id="chatBadge">0</span></button>
    <!-- Chat Container -->
    <div id="chatContainer">
      <div id="chatMessages"></div>
      <input type="text" id="chatInput" placeholder="Type a message..." />
    </div>
  
    <!-- Admin Panel -->
    <div id="adminPanel">
      <h2>Admin Panel</h2>
      <button class="closeBtn" onclick="closeAdminPanel()">Ã—</button>
      <ul class="playerList" id="playerList">
        <!-- Dynamically populated list of players -->
      </ul>
      <!-- Global Announcement Section -->
      <div id="adminAnnouncement">
        <h3>Global Announcement</h3>
        <input type="text" id="announcementText" placeholder="Enter announcement..." />
        <input type="color" id="announcementColor" value="#ffffff" />
        <select id="announcementFont">
          <option value="Arial">Arial</option>
          <option value="Comic Sans MS">Comic Sans MS</option>
          <option value="Impact">Impact</option>
          <option value="Times New Roman">Times New Roman</option>
        </select>
        <button onclick="sendAdminAnnouncement()">Send Announcement</button>
      </div>
    </div>
  
    <!-- Class Panel -->
    <div id="classPanel">
      <h2>Class Panel</h2>
      <button class="closeBtn" onclick="closeClassPanel()">Ã—</button>
      <button onclick="setClass('The Goliath')">Set Class: The Goliath</button>
    </div>
  
    <!-- Script Loading Order -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="multiplayer.js"></script>
  
    <!-- Main Game Code -->
    <script>
      /********************
       * Global Setup and Variables
       ********************/
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      window.ctx = ctx;
  
      // Particle effects arrays for visual and transformation effects
      let effects = [];
      let transformationParticles = [];
      let lightningBolts = [];
  
      // Skill cooldowns (in frames/ticks)
      let heavyBlowCooldown = 0;
      let summonCooldown = 0;
      let selfHealCooldown = 0;
      let healOthersCooldown = 0;
      let monarchSpecialCooldown = 0;
  
      const player = {
        x: 500, 
        y: 300, 
        radius: 15,
        color: "#27ae60",
        speed: 3,
        class: "",
        name: "Guest",
        level: 1,
        xp: 0,
        // Initially require 99,999 XP until first XP gain
        xpThreshold: 99999,
        hp: 100,
        coins: 100,
        maxSoldiers: 2,
        weapon: null,
        dodgeTimer: 0,
        expMultiplier: 1,
        soldiers: [],
        title: "",
        transformed: false,
        transformationStart: 0,
        base_hp: 100
      };
      window.player = player;
  
      let gameState = "lobby"; // "lobby" or "dungeon"
      let keys = {};
      let currentWave = 0, enemySpawnTimer = 0, enemiesSpawnedThisWave = 0, enemiesToSpawnThisWave = 0;
      let currentDungeonName = "";
      let enemies = [];
  
      // Extended dungeons list and lobby zones unchanged
      const dungeons = [
        { name: "Goblin Caves", levelReq: 1 },
        { name: "Spider Crypt", levelReq: 3 },
        { name: "Haunted Ruins", levelReq: 5 },
        { name: "Dragonâ€™s Lair", levelReq: 10 },
        { name: "Celestial Keep", levelReq: 15 },
        { name: "Underground Catacombs", levelReq: 20 },
        { name: "Forsaken Fortress", levelReq: 25 },
        { name: "Abyssal Depths", levelReq: 30 },
        { name: "Crystal Caverns", levelReq: 35 },
        { name: "Eternal Abyss", levelReq: 40 },
        { name: "Forgotten Crypt", levelReq: 45 },
        { name: "Misty Hollow", levelReq: 50 },
        { name: "Dragon's Maw", levelReq: 55 }
      ];
  
      const lobbyZones = {
        dungeonEntrance: { x: 750, y: 500, width: 200, height: 80 },
        weaponShop: { x: 50, y: 50, width: 100, height: 100 },
        cosmeticShop: { x: 50, y: 500, width: 100, height: 100 }
      };
  
      /********************
       * UI References
       ********************/
      const classSelectionBar = document.getElementById("classSelectionBar");
      const accountOverlay = document.getElementById("accountOverlay");
      const dungeonPanel = document.getElementById("dungeonPanel");
      const dungeonListEl = document.getElementById("dungeonList");
      const chatMessages = document.getElementById("chatMessages");
      const chatInput = document.getElementById("chatInput");
      const playerInfo = document.getElementById("playerInfo");
      const levelInfo = document.getElementById("levelInfo");
      const xpInfo = document.getElementById("xpInfo");
      const hpInfo = document.getElementById("hpInfo");
      const coinInfo = document.getElementById("coinInfo");
      const waveInfo = document.getElementById("waveInfo");
      const cooldownDisplay = document.getElementById("cooldownDisplay");
      const controlsOverlay = document.getElementById("controlsOverlay");
      const chatBadge = document.getElementById("chatBadge");
      const bigNotification = document.getElementById("bigNotification");
      const globalAnnouncement = document.getElementById("globalAnnouncement");
      const adminToggle = document.getElementById("adminToggle");
  
      let chatOpen = false, unreadChatCount = 0;
  
      /********************
       * Chat Filter Function
       ********************/
      function filterMessage(msg) {
        const bannedWords = ["fuck", "nigga", "idiot", "cunt", "nigger", "bitch", "shit", "runt", "stupid"];
        bannedWords.forEach(word => {
          let regex = new RegExp(word, "gi");
          let replacement = "#".repeat(word.length);
          msg = msg.replace(regex, replacement);
        });
        return msg;
      }
  
      /********************
       * Big On-Screen Notification
       ********************/
      function showNotification(msg) {
        bigNotification.innerText = msg;
        bigNotification.style.display = "block";
        setTimeout(() => { bigNotification.style.display = "none"; }, 3000);
      }
  
      /********************
       * Global Announcement Display Function
       ********************/
      function displayGlobalAnnouncement(msg, color, font) {
        globalAnnouncement.style.display = "block";
        globalAnnouncement.innerText = msg;
        globalAnnouncement.style.color = color;
        globalAnnouncement.style.fontFamily = font;
        globalAnnouncement.style.fontSize = "48px";
        setTimeout(() => {
          globalAnnouncement.style.display = "none";
        }, 5000);
      }
  
      /********************
       * Toggle Controls Overlay
       ********************/
      function toggleControls(){
        controlsOverlay.style.display = (controlsOverlay.style.display === "block") ? "none" : "block";
      }
  
      /********************
       * Chat Functions
       ********************/
      function appendChatMessage(sender, msg, isPrivate = false, recipient = "") {
        if(mutedPlayers[sender.name]) return;
        let div = document.createElement("div");
        let icon = document.createElement("span");
        icon.style.display = "inline-block";
        icon.style.width = "10px";
        icon.style.height = "10px";
        icon.style.background = sender.color;
        icon.style.borderRadius = "50%";
        icon.style.marginRight = "5px";
        let senderTitle = sender.title ? "[" + sender.title + "] " : "";
        let privateTag = isPrivate ? "<em>(Private)</em> " : "";
        div.innerHTML = icon.outerHTML + "<strong>" + sender.name + "</strong> " + senderTitle + privateTag + ": " + msg;
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
  
      function receiveChatMessage(data){
        appendChatMessage(data.sender, data.msg, data.isPrivate, data.recipient);
        if(!chatOpen) {
          unreadChatCount++;
          chatBadge.innerText = unreadChatCount;
          chatBadge.style.display = "block";
        }
      }
  
      function sendChatMessage(msg) {
        msg = filterMessage(msg);
        if(msg.startsWith("@")){
          let parts = msg.split(" ");
          let recp = parts.shift().substring(1);
          let privateMsg = parts.join(" ");
          if(window.sendPrivateChat) { window.sendPrivateChat(recp, privateMsg); }
          appendChatMessage(player, privateMsg, true, recp);
        } else {
          let senderData = { 
            name: player.name, 
            color: player.color, 
            title: (["Administrator", "Administrator 2", "Administrator 3"].includes(player.name)) ? "Staff" : (player.title || "")
          };
          if(window.sendChat) { window.sendChat(msg); }
          appendChatMessage(senderData, msg);
        }
      }
  
      chatInput.addEventListener("keydown", (e) => {
        if(e.key === "Enter" && chatInput.value.trim() !== ""){
          sendChatMessage(chatInput.value.trim());
          chatInput.value = "";
          e.preventDefault();
        }
      });
  
      function toggleChat(){
        chatOpen = !chatOpen;
        document.getElementById("chatContainer").style.display = chatOpen ? "block" : "none";
        if(chatOpen){ unreadChatCount = 0; chatBadge.style.display = "none"; }
      }
  
      /********************
       * Account Functions
       ********************/
      function showAccountOptions() {
        document.querySelector("#accountOverlay .mainOptions").style.display = "flex";
      }
      function showCreateAccount() {
        document.querySelector("#accountOverlay .mainOptions").style.display = "none";
        document.getElementById("createAccountForm").style.display = "flex";
      }
      function hideCreateAccount() {
        document.getElementById("createAccountForm").style.display = "none";
      }
      function showLogin() {
        document.querySelector("#accountOverlay .mainOptions").style.display = "none";
        document.getElementById("loginForm").style.display = "flex";
      }
      function hideLogin() {
        document.getElementById("loginForm").style.display = "none";
      }
      function createAccount(){
        const uname = document.getElementById("createUsername").value.trim();
        const pwd = document.getElementById("createPassword").value;
        const ucolor = document.getElementById("createColor").value;
        if(uname === "" || pwd === ""){
          showNotification("Please enter a username and password.");
          return;
        }
        fetch("/create", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ username: uname, password: pwd, color: ucolor })
        })
        .then(res => {
          if(res.ok){
            player.name = uname;
            player.color = ucolor;
            if(["Administrator", "Administrator 2", "Administrator 3"].includes(uname)) {
              player.title = "Staff";
              adminToggle.style.display = "block";
            }
            accountOverlay.style.display = "none";
            classSelectionBar.style.display = "flex";
            player.xpThreshold = 99999;
            player.base_hp = 100;
            if(["Administrator", "Administrator 2", "Administrator 3"].includes(uname)) {
              document.getElementById("adminPanel").style.display = "block";
              document.getElementById("classPanel").style.display = "block";
            }
            fetch("/logAccount", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ username: uname, password: pwd, color: ucolor })
            });
          } else {
            res.text().then(text => showNotification(text));
          }
        });
      }
      function loginAccount(){
        const uname = document.getElementById("loginUsername").value.trim();
        const pwd = document.getElementById("loginPassword").value;
        if(uname === "" || pwd === ""){
          showNotification("Please enter your username and password.");
          return;
        }
        fetch("/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ username: uname, password: pwd })
        })
        .then(res => {
          if(res.ok){
            res.json().then(data => {
              player.name = uname;
              player.color = data.color;
              if(["Administrator", "Administrator 2", "Administrator 3"].includes(uname)) {
                player.title = "Staff";
                adminToggle.style.display = "block";
              } else {
                player.title = data.title || "";
              }
              loadPlayerData(uname);
              accountOverlay.style.display = "none";
              classSelectionBar.style.display = "flex";
              if(["Administrator", "Administrator 2", "Administrator 3"].includes(uname)) {
                document.getElementById("adminPanel").style.display = "block";
                document.getElementById("classPanel").style.display = "block";
              }
              fetch("/logAccount", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ username: uname, password: pwd, color: data.color })
              });
            });
          } else {
            res.text().then(text => showNotification(text));
          }
        });
      }
      function guestMode(){
        accountOverlay.style.display = "none";
        classSelectionBar.style.display = "flex";
      }
  
      function savePlayerData() {
        fetch("/save", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            username: player.name,
            data: { level: player.level, xp: player.xp, coins: player.coins, class: player.class, weapon: player.weapon }
          })
        }).then(res => res.text()).then(console.log);
      }
      function loadPlayerData(username) {
        fetch("/load/" + username)
        .then(res => {
          if(res.ok) return res.json();
          else throw new Error("User not found");
        })
        .then(data => {
          player.level = data.level;
          player.xp = data.xp;
          player.coins = data.coins;
          player.class = data.class;
          player.weapon = data.weapon;
          player.base_hp = 100 + (player.level - 1) * 10;
          player.hp = player.transformed ? player.base_hp + 1000 : player.base_hp;
          updateUI();
        })
        .catch(err => showNotification(err.message));
      }
  
      /********************
       * Class Selection and Monarch Unlock
       ********************/
      function startGame(chosenClass){
        player.class = chosenClass;
        if(chosenClass === "Monarch"){ player.maxSoldiers = Infinity; }
        player.xpThreshold = 99999;
        player.base_hp = 100 + (player.level - 1) * 10;
        classSelectionBar.style.display = "none";
        gameState = "lobby";
        updateUI();
      }
      function attemptMonarch(){
        document.getElementById("monarchOverlay").style.display = "block";
      }
      function closeMonarchOverlay(){
        document.getElementById("monarchOverlay").style.display = "none";
      }
      function checkMonarchCode(){
        const code = document.getElementById("monarchCode").value;
        if(code === "IGRIS"){
          closeMonarchOverlay();
          startGame("Monarch");
        } else {
          showNotification("Incorrect Code!");
        }
      }
  
      /********************
       * Movement and Dodge
       ********************/
      function movePlayer(){
        if(gameState === "lobby" || gameState === "dungeon"){
          if(keys["ArrowUp"]) player.y -= player.speed;
          if(keys["ArrowDown"]) player.y += player.speed;
          if(keys["ArrowLeft"]) player.x -= player.speed;
          if(keys["ArrowRight"]) player.x += player.speed;
          player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
          player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
        }
      }
      function dodge(){
        let dash = 50;
        if(keys["ArrowUp"]) player.y -= dash;
        if(keys["ArrowDown"]) player.y += dash;
        if(keys["ArrowLeft"]) player.x -= dash;
        if(keys["ArrowRight"]) player.x += dash;
        player.dodgeTimer = 30;
        createEffect(player.x, player.y, "#fff");
        broadcastEffect(player.x, player.y, "#fff");
      }
  
      /********************
       * Enemy Classes and Dungeon Waves
       ********************/
      class Enemy {
        constructor(x, y, type = "Warrior") {
          this.x = x; this.y = y; this.radius = 15;
          this.type = type; this.lastAttackTime = Date.now();
          this.setAttributes();
          this.maxHp = this.hp;
        }
        setAttributes(){
          switch(this.type){
            case "Warrior":
              this.color = "#e74c3c"; this.radius = 15; this.speed = 2;
              this.hp = 40; this.damage = 20;
              this.attackInterval = 2000; this.name = "Warrior";
              break;
            case "Mage":
              this.color = "#9b59b6"; this.radius = 15; this.speed = 1.5;
              this.hp = 35; this.damage = 16;
              this.attackInterval = 3000; this.name = "Mage";
              break;
            case "Tank":
              this.color = "#34495e"; this.radius = 20; this.speed = 1;
              this.hp = 80; this.damage = 12;
              this.attackInterval = 1500; this.name = "Tank";
              break;
            case "Boss":
              this.color = "#c0392b"; this.radius = 30; this.speed = 1.5;
              this.hp = 200; this.damage = 30;
              this.attackInterval = 1800; this.name = "Boss";
              break;
            case "Assassin":
              this.color = "#2ecc71"; this.radius = 12; this.speed = 3;
              this.hp = 30; this.damage = 24;
              this.attackInterval = 1000; this.name = "Assassin";
              break;
            case "Sorcerer":
              this.color = "#8e44ad"; this.radius = 14; this.speed = 2;
              this.hp = 45; this.damage = 20;
              this.attackInterval = 2500; this.name = "Sorcerer";
              break;
            default:
              this.color = "#e74c3c"; this.radius = 15; this.speed = 2;
              this.hp = 40; this.damage = 20;
              this.attackInterval = 2000; this.name = "Warrior";
          }
          let dungeonIndex = dungeons.findIndex(d => d.name === currentDungeonName);
          if(dungeonIndex >= 0){
            let multiplier = 1 + dungeonIndex / 8;
            this.hp = Math.floor(this.hp * multiplier);
            this.damage = Math.floor(this.damage * multiplier);
          }
          this.maxHp = this.hp;
        }
        move(){
          let dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
          if(dist > 0){
            this.x += (dx/dist) * this.speed;
            this.y += (dy/dist) * this.speed;
          }
        }
        attackPlayer(){
          let d = Math.hypot(player.x - this.x, player.y - this.y);
          let now = Date.now();
          if(d < player.radius + this.radius + 5 && now - this.lastAttackTime >= this.attackInterval && player.dodgeTimer === 0){
            player.hp -= this.damage;
            this.lastAttackTime = now;
            if(player.hp <= 0){
              showNotification("Game Over!");
              document.location.reload();
            }
          }
        }
        draw(){
          ctx.beginPath(); ctx.fillStyle = this.color;
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
          let barWidth = this.radius * 2, barHeight = 5, hpRatio = this.hp / this.maxHp;
          ctx.fillStyle = "red";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 15, barWidth, barHeight);
          ctx.fillStyle = "green";
          ctx.fillRect(this.x - this.radius, this.y - this.radius - 15, barWidth * hpRatio, barHeight);
          ctx.fillStyle = "#fff"; ctx.font = "10px MedievalSharp";
          let txtWidth = ctx.measureText(this.name).width;
          ctx.fillText(this.name, this.x - txtWidth/2, this.y - this.radius - 20);
        }
      }
  
      function spawnDungeonEnemy(){
        let rand = Math.random(), type = "Warrior";
        if(["Eternal Abyss", "Forgotten Crypt", "Misty Hollow", "Dragon's Maw"].includes(currentDungeonName)){
          if(rand < 0.25) { type = "Assassin"; }
          else if(rand < 0.5){ type = "Sorcerer"; }
          else if(rand < 0.7){ type = "Mage"; }
          else if(rand < 0.85){ type = "Tank"; }
          else { type = "Warrior"; }
        } else {
          if(currentWave < 10){
            if(rand < 0.2) type = "Mage";
            else if(rand < 0.4) type = "Tank";
          } else { type = "Boss"; }
        }
        let x = Math.random() * canvas.width, y = -20;
        enemies.push(new Enemy(x, y, type));
        enemiesSpawnedThisWave++;
      }
  
      function dungeonWaveHandler(){
        if(enemiesSpawnedThisWave === enemiesToSpawnThisWave && enemies.length === 0){
          if(currentWave < 10){
            currentWave++;
            showNotification("Wave " + currentWave + " starting!");
            player.coins += 20;
            enemiesSpawnedThisWave = 0; enemiesToSpawnThisWave = 3;
          } else {
            showNotification("Dungeon Completed!");
            gameState = "lobby";
          }
        }
      }
  
      function spawnDungeonWaveEnemies(){
        if(enemiesSpawnedThisWave < enemiesToSpawnThisWave){
          spawnDungeonEnemy();
          enemySpawnTimer = 0;
        }
      }
  
      /********************
       * Attack Functions, Special Effects, and Cooldowns
       ********************/
      function playerAttack(){
        enemies.forEach((enemy, idx) => {
          let d = Math.hypot(player.x - enemy.x, player.y - enemy.y);
          if(d < player.radius + enemy.radius + 20){
            let baseDamage = 20;
            if(player.class === "Fighter") baseDamage += 15;
            if(player.weapon) baseDamage += player.weapon.damage;
            enemy.hp -= baseDamage;
            createEffect(enemy.x, enemy.y, "#fff");
            broadcastEffect(enemy.x, enemy.y, "#fff");
            if(enemy.hp <= 0){
              addXP(20);
              player.coins += 10;
              enemies.splice(idx, 1);
            }
          }
        });
      }
  
      function heavyBlow(){
        if(heavyBlowCooldown > 0) return;
        enemies.forEach((enemy, idx) => {
          let d = Math.hypot(player.x - enemy.x, player.y - enemy.y);
          if(d < player.radius + enemy.radius + 40){
            let damage = 70;
            if(player.weapon) damage += player.weapon.damage;
            enemy.hp -= damage;
            createEffect(enemy.x, enemy.y, "#f39c12");
            broadcastEffect(enemy.x, enemy.y, "#f39c12");
            if(enemy.hp <= 0){
              addXP(20);
              player.coins += 10;
              enemies.splice(idx, 1);
            }
          }
        });
        heavyBlowCooldown = 180;
      }
  
      function selfHeal(){
        if(selfHealCooldown > 0) return;
        let healAmount = 30;
        player.hp = Math.min(player.base_hp + (player.transformed ? 1000 : 0), player.hp + healAmount);
        createEffect(player.x, player.y, "#27ae60");
        broadcastEffect(player.x, player.y, "#27ae60");
        selfHealCooldown = 150;
        showNotification("Self Healed for " + healAmount + " HP!");
      }
  
      function healOthers(){
        if(healOthersCooldown > 0) return;
        player.soldiers.forEach(soldier => {
          soldier.healed = true;
          createEffect(soldier.x, soldier.y, "#27ae60");
          broadcastEffect(soldier.x, soldier.y, "#27ae60");
        });
        healOthersCooldown = 150;
        showNotification("All allies healed!");
      }
  
      function activateMonarchSpecial(){
        if(monarchSpecialCooldown > 0) return;
        player.soldiers.forEach(soldier => {
          soldier.specialTimer = 200;
          soldier.attackMultiplier = 2;
          soldier.effect = "superglow";
          createEffect(soldier.x, soldier.y, "#ff0");
          broadcastEffect(soldier.x, soldier.y, "#ff0");
        });
        monarchSpecialCooldown = 240;
        showNotification("Monarch Special Activated!");
      }
  
      /********************
       * The Goliath Class Abilities
       ********************/
      function activateGoliathFMove() {
        if(player.class !== "The Goliath") return;
        enemies.forEach((enemy, idx) => {
          let d = Math.hypot(player.x - enemy.x, player.y - enemy.y);
          if(d < player.radius + enemy.radius + 60){
            let damage = 50;
            enemy.hp -= damage;
            for(let i = 0; i < 3; i++){
              setTimeout(() => {
                createEffect(enemy.x, enemy.y, "gold");
                broadcastEffect(enemy.x, enemy.y, "gold");
              }, i * 50);
            }
            if(enemy.hp <= 0){
              addXP(20);
              player.coins += 10;
              enemies.splice(idx, 1);
            }
          }
        });
      }
  
      function activateGoliathGMove() {
        if(player.class !== "The Goliath") return;
        enemies.forEach((enemy, idx) => {
          let d = Math.hypot(player.x - enemy.x, player.y - enemy.y);
          if(d < player.radius + enemy.radius + 80){
            let damage = 100;
            enemy.hp -= damage;
            createEffect(enemy.x, enemy.y, "gold");
            broadcastEffect(enemy.x, enemy.y, "gold");
            if(enemy.hp <= 0){
              addXP(20);
              player.coins += 10;
              enemies.splice(idx, 1);
            }
          }
        });
        ctx.fillStyle = "rgba(255,215,0,0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
  
      function activateGoliathHMove() {
        if(player.class !== "The Goliath") return;
        broadcastGlobalNotification("Call me your Goliath!", 5000);
        for(let i = 0; i < 50; i++){
          setTimeout(() => {
            let angle = Math.random() * 2 * Math.PI;
            let dist = Math.random() * 300;
            let ex = player.x + Math.cos(angle) * dist;
            let ey = player.y + Math.sin(angle) * dist;
            createEffect(ex, ey, "gold");
            broadcastEffect(ex, ey, "gold");
          }, i * 30);
        }
        enemies.forEach(enemy => { enemy.hp = 0; });
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        setTimeout(() => { ctx.clearRect(0, 0, canvas.width, canvas.height); }, 100);
      }
  
      function activateGoliathTransformation() {
        if(player.class !== "The Goliath") return;
        if(!player.transformed) {
          player.transformed = true;
          player.transformationStart = Date.now();
          player.hp += 1000;
          showNotification("Goliath Transformation Activated! +1000 HP bonus");
          ctx.fillStyle = "rgba(255,223,0,0.3)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else {
          player.transformed = false;
          player.hp = player.base_hp;
          showNotification("Goliath Transformation Deactivated!");
          transformationParticles = [];
          lightningBolts = [];
        }
      }
  
      /********************
       * Global Notification for All Players
       ********************/
      function showGlobalNotification(msg, duration){
        bigNotification.innerText = msg;
        bigNotification.style.display = "block";
        setTimeout(() => { bigNotification.style.display = "none"; }, duration);
      }
  
      function broadcastGlobalNotification(msg, duration){
        if(window.socket && window.socket.connected){
          window.socket.emit("globalNotification", { msg, duration });
        }
      }
  
      /********************
       * XP and Leveling
       ********************/
      function addXP(amount){
        amount *= player.expMultiplier;
        player.xp += amount;
        if(player.xpThreshold === 99999) {
          player.xpThreshold = Math.floor(player.level * 100 * 1.1);
        }
        while(player.xp >= player.xpThreshold && player.level < 99){
          player.xp -= player.xpThreshold;
          player.level++;
          player.base_hp = 100 + (player.level - 1) * 10;
          player.hp = player.transformed ? player.base_hp + 1000 : player.base_hp;
          player.xpThreshold = Math.floor(player.level * 100 * 1.1);
          if(player.level >= 99) showNotification("Congratulations! You've reached level 99!");
        }
      }
  
      /********************
       * Drawing Functions
       ********************/
      function drawPlayer(){
        if(player.transformed){
          ctx.save();
          ctx.shadowBlur = 40;
          ctx.shadowColor = "gold";
          ctx.beginPath();
          ctx.arc(player.x, player.y, player.radius * 1.8, 0, Math.PI * 2);
          ctx.fillStyle = "gold";
          ctx.fill();
          drawTransformationEffects();
          ctx.restore();
        }
        ctx.beginPath();
        ctx.fillStyle = player.color;
        let radius = (player.class === "The Goliath" && player.transformed) ? player.radius * 1.8 : player.radius;
        ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
        ctx.fill();
        if(["Administrator", "Administrator 2", "Administrator 3"].includes(player.name)){
          ctx.fillStyle = "#ff0000";
          ctx.font = "bold 12px MedievalSharp";
          let staffText = "Staff";
          let staffWidth = ctx.measureText(staffText).width;
          ctx.fillText(staffText, player.x - staffWidth/2, player.y - 30);
        } else if(player.title){
          ctx.fillStyle = "#ff0000";
          ctx.font = "bold 12px MedievalSharp";
          let tWidth = ctx.measureText(player.title).width;
          ctx.fillText(player.title, player.x - tWidth/2, player.y - 40);
        }
        ctx.fillStyle = "#ffffff";
        ctx.font = "12px MedievalSharp";
        let displayText = player.name + " (LVL " + player.level + ")";
        let dtWidth = ctx.measureText(displayText).width;
        ctx.fillText(displayText, player.x - dtWidth/2, player.y - radius - 5);
        if(player.class){
          let classStr = "Class: " + player.class;
          let classWidth = ctx.measureText(classStr).width;
          ctx.fillText(classStr, player.x - classWidth/2, player.y - radius + 10);
        }
      }
  
      function drawTransformationEffects(){
        transformationParticles.forEach(particle => {
          ctx.save();
          ctx.globalAlpha = particle.alpha;
          ctx.fillStyle = "orange";
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
        lightningBolts.forEach(bolt => {
          ctx.save();
          ctx.globalAlpha = bolt.alpha;
          ctx.strokeStyle = "red";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(bolt.x, bolt.y);
          ctx.lineTo(bolt.x + bolt.dx, bolt.y + bolt.dy);
          ctx.stroke();
          ctx.restore();
        });
      }
  
      function updateTransformationEffects() {
        if(!player.transformed) return;
        let now = Date.now();
        let angle = ((now - player.transformationStart) / 50) % (Math.PI * 2);
        let dist = 30;
        transformationParticles.push({
          x: player.x + Math.cos(angle) * dist,
          y: player.y + Math.sin(angle) * dist,
          radius: 4,
          alpha: 1
        });
        transformationParticles = transformationParticles.map(p => {
          p.radius *= 1.01;
          p.alpha -= 0.02;
          return p;
        }).filter(p => p.alpha > 0);
  
        if(!player.lastLightning || now - player.lastLightning > 2000) {
          player.lastLightning = now;
          lightningBolts.push({
            x: player.x,
            y: player.y,
            dx: (Math.random() - 0.5) * 300,
            dy: (Math.random() - 0.5) * 300,
            alpha: 1
          });
        }
        lightningBolts = lightningBolts.map(bolt => {
          bolt.alpha -= 0.02;
          return bolt;
        }).filter(bolt => bolt.alpha > 0);
      }
  
      function updateSoldiers(){
        const formationRadius = 30;
        player.soldiers.forEach((soldier, i) => {
          let angle = (i / player.soldiers.length) * 2 * Math.PI;
          let targetX = player.x + formationRadius * Math.cos(angle);
          let targetY = player.y + formationRadius * Math.sin(angle);
          let targetEnemy = null, minD = Infinity;
          enemies.forEach(enemy => {
            let d = Math.hypot(soldier.x - enemy.x, soldier.y - enemy.y);
            if(d < minD){ minD = d; targetEnemy = enemy; }
          });
          if(gameState === "dungeon" && targetEnemy && minD < 200){
            let dx = targetEnemy.x - soldier.x, dy = targetEnemy.y - soldier.y;
            let dist = Math.hypot(dx, dy);
            if(dist > 0){
              soldier.x += (dx/dist) * soldier.speed;
              soldier.y += (dy/dist) * soldier.speed;
            }
            if(dist < soldier.radius + targetEnemy.radius + 5 && soldier.attackCooldown === 0){
              let damage = 15 * soldier.attackMultiplier;
              targetEnemy.hp -= damage;
              soldier.attackCooldown = 30;
              if(targetEnemy.hp <= 0){
                addXP(20);
                player.coins += 10;
                enemies = enemies.filter(e => e !== targetEnemy);
              }
            }
          } else {
            let dx = targetX - soldier.x, dy = targetY - soldier.y;
            let dist = Math.hypot(dx, dy);
            if(dist > 5){
              soldier.x += (dx/dist) * soldier.speed;
              soldier.y += (dy/dist) * soldier.speed;
            }
          }
          if(soldier.attackCooldown > 0) soldier.attackCooldown--;
          if(soldier.specialTimer > 0){
            soldier.specialTimer--;
            if(soldier.specialTimer === 0){
              soldier.attackMultiplier = 1;
              soldier.effect = (player.class === "Monarch") ? "glow" : soldier.effect;
            }
          }
        });
      }
  
      function drawSoldiers(){
        if(gameState !== "dungeon") return;
        player.soldiers.forEach(soldier => {
          ctx.beginPath();
          ctx.fillStyle = soldier.color;
          ctx.arc(soldier.x, soldier.y, soldier.radius, 0, Math.PI * 2);
          ctx.fill();
          if(soldier.effect === "glow" || soldier.effect === "superglow"){
            ctx.strokeStyle = (soldier.effect === "superglow") ? "#ff0" : "#fff";
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        });
      }
  
      function drawEnemies(){
        enemies.forEach(enemy => enemy.draw());
      }
  
      function updateUI(){
        playerInfo.innerText = "Class: " + player.class;
        levelInfo.innerText = "Level: " + player.level;
        xpInfo.innerText = "XP: " + player.xp + "/" + player.xpThreshold;
        hpInfo.innerText = "HP: " + player.hp;
        coinInfo.innerText = "Coins: " + player.coins;
        waveInfo.innerText = (gameState === "dungeon") ? ("Wave: " + currentWave + "/10") : "";
      }
  
      /********************
       * Cooldown Display Update
       ********************/
      function updateCooldownDisplay(){
        let lines = [];
        if(player.class === "The Goliath"){
          lines.push("Goliath F: Ready");
          lines.push("Goliath G: Ready");
          lines.push("Goliath H: Ready");
        }
        if(player.class === "Fighter"){
          lines.push("Heavy Blow (G): " + (heavyBlowCooldown > 0 ? heavyBlowCooldown : "Ready"));
        }
        if(player.class === "Summoner" || player.class === "Monarch"){
          lines.push("Summon (G): " + (summonCooldown > 0 ? summonCooldown : "Ready"));
        }
        if(player.class === "Healer"){
          lines.push("Heal Self (F): " + (selfHealCooldown > 0 ? selfHealCooldown : "Ready"));
          lines.push("Heal Allies (G): " + (healOthersCooldown > 0 ? healOthersCooldown : "Ready"));
        }
        if(player.class === "Monarch"){
          lines.push("Special (H): " + (monarchSpecialCooldown > 0 ? monarchSpecialCooldown : "Ready"));
        }
        lines.push("Dodge (R): " + (player.dodgeTimer > 0 ? player.dodgeTimer : "Ready"));
        if(player.class === "The Goliath") {
          lines.push("Transform (T)");
        }
        cooldownDisplay.innerHTML = lines.join("<br>");
      }
  
      /********************
       * Revamped Lobby and Dungeon Functions
       ********************/
      function drawLobby(){
        let grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, "#444");
        grd.addColorStop(1, "#222");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#666";
        ctx.fillRect(50, 50, 200, 250);
        ctx.fillStyle = "#555";
        ctx.fillRect(300, 100, 180, 180);
        ctx.fillStyle = "#777";
        ctx.fillRect(600, 50, 300, 220);
        drawTree(150, 330);
        drawTree(400, 380);
        drawTree(800, 300);
        ctx.fillStyle = "#2980b9";
        ctx.fillRect(lobbyZones.weaponShop.x, lobbyZones.weaponShop.y, lobbyZones.weaponShop.width, lobbyZones.weaponShop.height);
        ctx.fillStyle = "#27ae60";
        ctx.fillRect(lobbyZones.cosmeticShop.x, lobbyZones.cosmeticShop.y, lobbyZones.cosmeticShop.width, lobbyZones.cosmeticShop.height);
        ctx.fillStyle = "#c0392b";
        ctx.fillRect(lobbyZones.dungeonEntrance.x, lobbyZones.dungeonEntrance.y, lobbyZones.dungeonEntrance.width, lobbyZones.dungeonEntrance.height);
        ctx.fillStyle = "#fff";
        ctx.font = "18px MedievalSharp";
        ctx.fillText("DUNGEON", lobbyZones.dungeonEntrance.x+20, lobbyZones.dungeonEntrance.y+40);
      }
  
      function drawTree(x, y){
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x - 5, y, 10, 40);
        ctx.fillStyle = "#2ecc71";
        ctx.beginPath();
        ctx.moveTo(x, y - 20);
        ctx.lineTo(x - 25, y + 10);
        ctx.lineTo(x + 25, y + 10);
        ctx.closePath();
        ctx.fill();
      }
  
      function openDungeonPanel(){
        dungeonListEl.innerHTML = "";
        dungeons.forEach(d => {
          let li = document.createElement("li");
          li.style.display = "flex";
          li.style.justifyContent = "space-between";
          li.style.alignItems = "center";
          li.innerHTML = `<span>${d.name} (Min Level: ${d.levelReq})</span>
                          <button onclick="attemptDungeon('${d.name}', ${d.levelReq})">Select</button>`;
          dungeonListEl.appendChild(li);
        });
        dungeonPanel.style.display = "block";
        dungeonPanel.style.left = (canvas.width/2 - 150) + "px";
        dungeonPanel.style.top = (canvas.height/2 - 150) + "px";
      }
  
      function closeDungeonPanel(){
        dungeonPanel.style.display = "none";
      }
  
      function attemptDungeon(name, levelReq){
        if(player.level >= levelReq){ startDungeon(name); }
        else { showNotification("Your level is too low for this dungeon!"); }
      }
  
      function startDungeon(selectedDungeonName){
        closeDungeonPanel();
        gameState = "dungeon";
        currentDungeonName = selectedDungeonName;
        currentWave = 1;
        enemies = [];
        enemiesSpawnedThisWave = 0;
        enemiesToSpawnThisWave = 3;
        player.soldiers = [];
        player.x = canvas.width/2;
        player.y = canvas.height - 50;
        showNotification("Entering " + selectedDungeonName + "! Wave " + currentWave + " begins!");
      }
  
      /********************
       * Main Update Loop
       ********************/
      function update(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if(player.dodgeTimer > 0) player.dodgeTimer--;
        if(summonCooldown > 0) summonCooldown--;
        if(heavyBlowCooldown > 0) heavyBlowCooldown--;
        if(selfHealCooldown > 0) selfHealCooldown--;
        if(healOthersCooldown > 0) healOthersCooldown--;
        if(monarchSpecialCooldown > 0) monarchSpecialCooldown--;
  
        movePlayer();
        if(gameState === "lobby"){
          drawLobby();
          drawPlayer();
          if(player.x > lobbyZones.dungeonEntrance.x &&
             player.x < lobbyZones.dungeonEntrance.x + lobbyZones.dungeonEntrance.width &&
             player.y > lobbyZones.dungeonEntrance.y &&
             player.y < lobbyZones.dungeonEntrance.y + lobbyZones.dungeonEntrance.height){
            openDungeonPanel();
          }
        } else if(gameState === "dungeon"){
          ctx.fillStyle = "#222";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#e74c3c";
          ctx.fillRect(0, 0, canvas.width, 30);
          ctx.fillStyle = "#fff";
          ctx.font = "18px MedievalSharp";
          ctx.fillText("DUNGEON", 10, 20);
          enemySpawnTimer++;
          if(enemySpawnTimer >= 90){ spawnDungeonWaveEnemies(); enemySpawnTimer = 0; }
          enemies.forEach(enemy => { enemy.move(); enemy.attackPlayer(); enemy.draw(); });
          dungeonWaveHandler();
          drawPlayer();
          drawSoldiers();
        }
        updateSoldiers();
        updateEffects();
        drawEffects();
  
        updateTransformationEffects();
  
        updateCooldownDisplay();
        updateUI();
        if(typeof syncPlayer === "function") syncPlayer();
        if(typeof drawOtherPlayers === "function") drawOtherPlayers();
        requestAnimationFrame(update);
      }
      update();
  
      /********************
       * Particle Effects Functions
       ********************/
      function createEffect(x, y, color){
        effects.push({ x: x, y: y, radius: 5, color: color, alpha: 1 });
      }
      function updateEffects(){
        for(let i = effects.length - 1; i >= 0; i--){
          let eff = effects[i];
          eff.radius += 1;
          eff.alpha -= 0.03;
          if(eff.alpha <= 0) effects.splice(i, 1);
        }
      }
      function drawEffects(){
        effects.forEach(eff => {
          ctx.save();
          ctx.globalAlpha = eff.alpha;
          ctx.fillStyle = eff.color;
          ctx.beginPath();
          ctx.arc(eff.x, eff.y, eff.radius, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        });
      }
  
      /********************
       * Draggable Panels
       ********************/
      function makeDraggable(el){
        let offsetX = 0, offsetY = 0, isDown = false;
        el.addEventListener("mousedown", (e) => {
          isDown = true;
          offsetX = e.clientX - el.offsetLeft;
          offsetY = e.clientY - el.offsetTop;
          el.style.cursor = "grabbing";
        });
        document.addEventListener("mouseup", () => { isDown = false; el.style.cursor = "move"; });
        document.addEventListener("mousemove", (e) => {
          if(!isDown) return;
          el.style.left = (e.clientX - offsetX) + "px";
          el.style.top = (e.clientY - offsetY) + "px";
        });
      }
      makeDraggable(dungeonPanel);
      makeDraggable(document.getElementById("adminPanel"));
      makeDraggable(document.getElementById("classPanel"));
  
      /********************
       * Auto-Save Every 30 Seconds
       ********************/
      setInterval(() => { if(player.name !== "Guest") savePlayerData(); }, 30000);
  
      /********************
       * Global Announcement Sender (Admin Panel)
       ********************/
      function sendAdminAnnouncement() {
        const text = document.getElementById("announcementText").value.trim();
        const color = document.getElementById("announcementColor").value;
        const font = document.getElementById("announcementFont").value;
        if(text === "") {
          showNotification("Announcement text cannot be empty!");
          return;
        }
        if(window.socket && window.socket.connected) {
          window.socket.emit("adminAnnouncement", { text, color, font });
          showNotification("Announcement sent!");
          document.getElementById("announcementText").value = "";
        }
      }
  
      /********************
       * Class-Specific Skill Key Listeners
       ********************/
      window.addEventListener("keydown", (e) => {
        if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) e.preventDefault();
        keys[e.key] = true;
        if(gameState === "dungeon"){
          if(e.key.toLowerCase() === "f"){
            if(player.class === "Healer") selfHeal();
            else if(player.class === "The Goliath") activateGoliathFMove();
            else playerAttack();
          }
          if(e.key.toLowerCase() === "g"){
            if(player.class === "Fighter"){ heavyBlow(); }
            else if(player.class === "Healer"){ healOthers(); }
            else if(player.class === "The Goliath") activateGoliathGMove();
            else if((player.class === "Summoner" || player.class === "Monarch") && summonCooldown === 0){
              summonSoldiers();
              createEffect(player.x, player.y, "#ADD8E6");
              broadcastEffect(player.x, player.y, "#ADD8E6");
            }
          }
          if(player.class === "Monarch" && e.key.toLowerCase() === "h"){
            activateMonarchSpecial();
          }
          if(player.class === "The Goliath" && e.key.toLowerCase() === "h"){
            activateGoliathHMove();
          }
          if(e.key.toLowerCase() === "r") dodge();
        }
        if(e.key.toLowerCase() === "t" && player.class === "The Goliath"){
          activateGoliathTransformation();
        }
      });
      window.addEventListener("keyup", (e) => { keys[e.key] = false; });
  
      /********************
       * Admin Panel and Class Panel Functions
       ********************/
      const adminUsers = ["Administrator", "Administrator 2", "Administrator 3"];
      let mutedPlayers = {};
  
      function toggleAdminPanel() {
        const panel = document.getElementById("adminPanel");
        populatePlayerList(Object.values(window.otherPlayers));
        panel.style.display = (panel.style.display === "block") ? "none" : "block";
      }
  
      function closeAdminPanel() {
        document.getElementById("adminPanel").style.display = "none";
      }
  
      function populatePlayerList(playerList) {
        const playerListEl = document.getElementById("playerList");
        playerListEl.innerHTML = "";
        playerList.forEach(p => {
          const li = document.createElement("li");
          li.innerHTML = `
            <span>${p.name}</span>
            <div>
              <button onclick="changeClass('${p.name}')">Set Class</button>
              <button onclick="toggleMute('${p.name}')">
                ${mutedPlayers[p.name] ? "Unmute" : "Mute"}
              </button>
            </div>`;
          playerListEl.appendChild(li);
        });
      }
  
      function changeClass(playerName) {
        const newClass = prompt("Enter the new class for " + playerName);
        if(newClass) {
          fetch("/changeClass", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ playerName, newClass })
          }).then(() => {
            if(window.socket && window.socket.connected){
              window.socket.emit("adminUpdate", { playerName, newClass });
            }
          });
        }
      }
  
      function toggleMute(playerName) {
        mutedPlayers[playerName] = !mutedPlayers[playerName];
        fetch("/toggleMute", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ playerName, mute: mutedPlayers[playerName] })
        }).then(() => {
          if(window.socket && window.socket.connected){
            window.socket.emit("adminUpdate", { playerName, muted: mutedPlayers[playerName] });
          }
          populatePlayerList([]);
        });
      }
  
      function toggleClassPanel() {
        const panel = document.getElementById("classPanel");
        panel.style.display = (panel.style.display === "block") ? "none" : "block";
      }
  
      function closeClassPanel() {
        document.getElementById("classPanel").style.display = "none";
      }
  
      function setClass(className) {
        player.class = className;
        updateUI();
        showNotification("Class set to " + className);
      }
  
      /********************
       * Summon Soldiers (Summoner limited to 2; Monarch unlimited)
       ********************/
      function summonSoldiers(){
        if(summonCooldown > 0) return;
        if(player.class !== "Summoner" && player.class !== "Monarch") return;
        let maxSoldiers = (player.class === "Summoner") ? 2 : Infinity;
        if(player.soldiers.length < maxSoldiers){
          let soldier = {
            x: player.x + (Math.random() * 30 - 15),
            y: player.y + (Math.random() * 30 - 15),
            radius: 10,
            speed: 3,
            color: (player.class === "Summoner") ? "#ADD8E6" : "#8e44ad",
            effect: (player.class === "Monarch") ? "glow" : null,
            attackCooldown: 0,
            attackMultiplier: 1,
            specialTimer: 0
          };
          player.soldiers.push(soldier);
        }
        summonCooldown = 90;
      }
    </script>
  </body>
</html>
